//
//  Icons.swift
//  PennyWise
//
//  Created by Caroline on 10/14/17.
//  Copyright Â© 2017 Razeware. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//
//  This code was generated by Trial version of PaintCode, therefore cannot be used for commercial purposes.
//



import UIKit
class Icons : NSObject {
    
    //// Cache
    
    private struct Cache {
        static let unSelectedColor: UIColor = UIColor.white
        static let selectedColor: UIColor = UIColor.red
    }
    
    //// Colors
    class var unSelectedColor: UIColor { return Cache.unSelectedColor }
    class var selectedColor: UIColor { return Cache.selectedColor }
    
    //// Drawing Methods
    
    class func drawGroceries(frame: CGRect = CGRect(x: 0, y: 0, width: 400, height: 400), isSelected: Bool = false) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }
        
        //// Variable Declarations
        let expression = isSelected ? Icons.selectedColor : Icons.unSelectedColor
        
        //// Subframes
        let cart: CGRect = CGRect(x: frame.minX + fastFloor(frame.width * 0.08125) + 0.5, y: frame.minY + fastFloor(frame.height * 0.07375) + 0.5, width: fastFloor(frame.width * 0.91875) - fastFloor(frame.width * 0.08125), height: fastFloor(frame.height * 0.92375) - fastFloor(frame.height * 0.07375))
        
        
        //// Cart
        //// Basket
        //// Cart Basket Bottom Drawing
        let cartBasketBottomPath = UIBezierPath()
        cartBasketBottomPath.move(to: CGPoint(x: cart.minX + 0.01562 * cart.width, y: cart.minY + 0.22794 * cart.height))
        cartBasketBottomPath.addLine(to: CGPoint(x: cart.minX + 0.15625 * cart.width, y: cart.minY + 0.59265 * cart.height))
        cartBasketBottomPath.addLine(to: CGPoint(x: cart.minX + 0.73438 * cart.width, y: cart.minY + 0.63824 * cart.height))
        cartBasketBottomPath.addLine(to: CGPoint(x: cart.minX + 0.85938 * cart.width, y: cart.minY + 0.22794 * cart.height))
        expression.setStroke()
        cartBasketBottomPath.lineWidth = 3
        cartBasketBottomPath.lineCapStyle = .round
        cartBasketBottomPath.lineJoinStyle = .bevel
        cartBasketBottomPath.stroke()
        
        
        //// Cart Basket Top Drawing
        let cartBasketTopPath = UIBezierPath()
        cartBasketTopPath.move(to: CGPoint(x: cart.minX + 0.00000 * cart.width, y: cart.minY + 0.22794 * cart.height))
        cartBasketTopPath.addLine(to: CGPoint(x: cart.minX + 0.85938 * cart.width, y: cart.minY + 0.22794 * cart.height))
        cartBasketTopPath.addLine(to: CGPoint(x: cart.minX + 0.90625 * cart.width, y: cart.minY + 0.04559 * cart.height))
        cartBasketTopPath.addLine(to: CGPoint(x: cart.minX + 1.00000 * cart.width, y: cart.minY + 0.00000 * cart.height))
        expression.setStroke()
        cartBasketTopPath.lineWidth = 3
        cartBasketTopPath.lineCapStyle = .round
        cartBasketTopPath.lineJoinStyle = .bevel
        cartBasketTopPath.stroke()
        
        //// Wheels
        //// Wheel 1 Drawing
        let wheel1Path = UIBezierPath(ovalIn: CGRect(x: cart.minX + fastFloor(cart.width * 0.15821 + 0.5), y: cart.minY + fastFloor(cart.height * 0.82941 + 0.5), width: fastFloor(cart.width * 0.33433 + 0.5) - fastFloor(cart.width * 0.15821 + 0.5), height: fastFloor(cart.height * 1.00000 + 0.5) - fastFloor(cart.height * 0.82941 + 0.5)))
        expression.setStroke()
        wheel1Path.lineWidth = 3
        wheel1Path.stroke()
        
        
        //// Wheel 2 Drawing
        let wheel2Path = UIBezierPath(ovalIn: CGRect(x: cart.minX + fastFloor(cart.width * 0.61493 + 0.5), y: cart.minY + fastFloor(cart.height * 0.82941 + 0.5), width: fastFloor(cart.width * 0.79104 + 0.5) - fastFloor(cart.width * 0.61493 + 0.5), height: fastFloor(cart.height * 1.00000 + 0.5) - fastFloor(cart.height * 0.82941 + 0.5)))
        expression.setStroke()
        wheel2Path.lineWidth = 3
        wheel2Path.stroke()
        
        
        
        
        //// Cart Base Drawing
        let cartBasePath = UIBezierPath()
        cartBasePath.move(to: CGPoint(x: cart.minX + 0.73463 * cart.width, y: cart.minY + 0.63694 * cart.height))
        cartBasePath.addCurve(to: CGPoint(x: cart.minX + 0.86731 * cart.width, y: cart.minY + 0.71338 * cart.height), controlPoint1: CGPoint(x: cart.minX + 0.73463 * cart.width, y: cart.minY + 0.63694 * cart.height), controlPoint2: CGPoint(x: cart.minX + 0.86731 * cart.width, y: cart.minY + 0.64013 * cart.height))
        cartBasePath.addCurve(to: CGPoint(x: cart.minX + 0.78125 * cart.width, y: cart.minY + 0.78462 * cart.height), controlPoint1: CGPoint(x: cart.minX + 0.86731 * cart.width, y: cart.minY + 0.78662 * cart.height), controlPoint2: CGPoint(x: cart.minX + 0.78125 * cart.width, y: cart.minY + 0.78462 * cart.height))
        cartBasePath.addLine(to: CGPoint(x: cart.minX + 0.10938 * cart.width, y: cart.minY + 0.78462 * cart.height))
        expression.setStroke()
        cartBasePath.lineWidth = 3
        cartBasePath.lineCapStyle = .round
        cartBasePath.lineJoinStyle = .bevel
        cartBasePath.stroke()
    }
    
    class func drawPet(frame: CGRect = CGRect(x: 0, y: 0, width: 400, height: 400), isSelected: Bool = false) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }
        
        
        //// Variable Declarations
        let expression = isSelected ? Icons.selectedColor : Icons.unSelectedColor
        
        
        //// Subframes
        let group: CGRect = CGRect(x: frame.minX + fastFloor(frame.width * 0.10750 + 0.5), y: frame.minY + fastFloor(frame.height * 0.10625) + 0.5, width: fastFloor(frame.width * 0.89500 + 0.5) - fastFloor(frame.width * 0.10750 + 0.5), height: fastFloor(frame.height * 0.89375) - fastFloor(frame.height * 0.10625))
        
        
        //// Group
        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: group.minX + fastFloor(group.width * 0.23333) + 0.5, y: group.minY + fastFloor(group.height * 0.41270 + 0.5), width: fastFloor(group.width * 0.76667) - fastFloor(group.width * 0.23333), height: fastFloor(group.height * 1.00000 + 0.5) - fastFloor(group.height * 0.41270 + 0.5)))
        expression.setStroke()
        ovalPath.lineWidth = 3
        ovalPath.stroke()
        
        
        //// Oval 2 Drawing
        let oval2Path = UIBezierPath(ovalIn: CGRect(x: group.minX + fastFloor(group.width * 0.00000 + 0.5), y: group.minY + fastFloor(group.height * 0.14762) + 0.5, width: fastFloor(group.width * 0.27619 + 0.5) - fastFloor(group.width * 0.00000 + 0.5), height: fastFloor(group.height * 0.42381) - fastFloor(group.height * 0.14762)))
        expression.setStroke()
        oval2Path.lineWidth = 3
        oval2Path.stroke()
        
        
        //// Oval 3 Drawing
        let oval3Path = UIBezierPath(ovalIn: CGRect(x: group.minX + fastFloor(group.width * 0.36190 + 0.5), y: group.minY + fastFloor(group.height * 0.00000 + 0.5), width: fastFloor(group.width * 0.63810 + 0.5) - fastFloor(group.width * 0.36190 + 0.5), height: fastFloor(group.height * 0.27619 + 0.5) - fastFloor(group.height * 0.00000 + 0.5)))
        expression.setStroke()
        oval3Path.lineWidth = 3
        oval3Path.stroke()
        
        
        //// Oval 4 Drawing
        let oval4Path = UIBezierPath(ovalIn: CGRect(x: group.minX + fastFloor(group.width * 0.72381 + 0.5), y: group.minY + fastFloor(group.height * 0.14762) + 0.5, width: fastFloor(group.width * 1.00000 + 0.5) - fastFloor(group.width * 0.72381 + 0.5), height: fastFloor(group.height * 0.42381) - fastFloor(group.height * 0.14762)))
        expression.setStroke()
        oval4Path.lineWidth = 3
        oval4Path.stroke()
    }
    
    class func drawFun(frame: CGRect = CGRect(x: 0, y: 0, width: 400, height: 400), isSelected: Bool = false) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }
    
        //// Variable Declarations
        let expression = isSelected ? Icons.selectedColor : Icons.unSelectedColor
        
        
        //// Subframes
        let group: CGRect = CGRect(x: frame.minX + fastFloor(frame.width * 0.11250 + 0.5), y: frame.minY + fastFloor(frame.height * 0.11000 + 0.5), width: fastFloor(frame.width * 0.89000 + 0.5) - fastFloor(frame.width * 0.11250 + 0.5), height: fastFloor(frame.height * 0.88750 + 0.5) - fastFloor(frame.height * 0.11000 + 0.5))
        
        
        //// Group
        //// Mouth Drawing
        let mouthPath = UIBezierPath()
        mouthPath.move(to: CGPoint(x: group.minX + 0.26812 * group.width, y: group.minY + 0.64493 * group.height))
        mouthPath.addCurve(to: CGPoint(x: group.minX + 0.50216 * group.width, y: group.minY + 0.83333 * group.height), controlPoint1: CGPoint(x: group.minX + 0.26812 * group.width, y: group.minY + 0.64493 * group.height), controlPoint2: CGPoint(x: group.minX + 0.28693 * group.width, y: group.minY + 0.83333 * group.height))
        mouthPath.addCurve(to: CGPoint(x: group.minX + 0.74638 * group.width, y: group.minY + 0.64493 * group.height), controlPoint1: CGPoint(x: group.minX + 0.71739 * group.width, y: group.minY + 0.83333 * group.height), controlPoint2: CGPoint(x: group.minX + 0.74638 * group.width, y: group.minY + 0.64493 * group.height))
        mouthPath.addLine(to: CGPoint(x: group.minX + 0.26812 * group.width, y: group.minY + 0.64493 * group.height))
        mouthPath.close()
        expression.setStroke()
        mouthPath.lineWidth = 3
        mouthPath.lineCapStyle = .round
        mouthPath.lineJoinStyle = .bevel
        mouthPath.stroke()
        
        
        //// Eye 1 Drawing
        let eye1Path = UIBezierPath(ovalIn: CGRect(x: group.minX + fastFloor(group.width * 0.29743) + 0.5, y: group.minY + fastFloor(group.height * 0.25241) + 0.5, width: fastFloor(group.width * 0.41318) - fastFloor(group.width * 0.29743), height: fastFloor(group.height * 0.48392) - fastFloor(group.height * 0.25241)))
        expression.setStroke()
        eye1Path.lineWidth = 3
        eye1Path.stroke()
        
        
        //// Eye 2 Drawing
        let eye2Path = UIBezierPath(ovalIn: CGRect(x: group.minX + fastFloor(group.width * 0.57395) + 0.5, y: group.minY + fastFloor(group.height * 0.25241) + 0.5, width: fastFloor(group.width * 0.68971) - fastFloor(group.width * 0.57395), height: fastFloor(group.height * 0.48392) - fastFloor(group.height * 0.25241)))
        expression.setStroke()
        eye2Path.lineWidth = 3
        eye2Path.stroke()
        
        
        //// Outside Drawing
        let outsidePath = UIBezierPath(ovalIn: CGRect(x: group.minX + fastFloor(group.width * 0.00000 + 0.5), y: group.minY + fastFloor(group.height * 0.00000 + 0.5), width: fastFloor(group.width * 1.00000 + 0.5) - fastFloor(group.width * 0.00000 + 0.5), height: fastFloor(group.height * 1.00000 + 0.5) - fastFloor(group.height * 0.00000 + 0.5)))
        expression.setStroke()
        outsidePath.lineWidth = 3
        outsidePath.stroke()
    }
    
    class func drawAutoIcon(frame: CGRect = CGRect(x: 0, y: 0, width: 400, height: 400), isSelected: Bool = false) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }
        
    
        //// Variable Declarations
        let expression = isSelected ? Icons.selectedColor : Icons.unSelectedColor
        
        
        //// Subframes
        let car: CGRect = CGRect(x: frame.minX + fastFloor(frame.width * 0.08375) + 0.5, y: frame.minY + fastFloor(frame.height * 0.20125) + 0.5, width: fastFloor(frame.width * 0.91653 - 0.11) - fastFloor(frame.width * 0.08375) + 0.11, height: fastFloor(frame.height * 0.79875) - fastFloor(frame.height * 0.20125))
        
        
        //// Car
        //// Car Body Drawing
        let carBodyPath = UIBezierPath()
        carBodyPath.move(to: CGPoint(x: car.minX + 0.04505 * car.width, y: car.minY + 0.36564 * car.height))
        carBodyPath.addCurve(to: CGPoint(x: car.minX + 0.20890 * car.width, y: car.minY + 0.29627 * car.height), controlPoint1: CGPoint(x: car.minX + 0.09719 * car.width, y: car.minY + 0.28471 * car.height), controlPoint2: CGPoint(x: car.minX + 0.20890 * car.width, y: car.minY + 0.29627 * car.height))
        carBodyPath.addCurve(to: CGPoint(x: car.minX + 0.47068 * car.width, y: car.minY + 0.00000 * car.height), controlPoint1: CGPoint(x: car.minX + 0.20890 * car.width, y: car.minY + 0.29627 * car.height), controlPoint2: CGPoint(x: car.minX + 0.29194 * car.width, y: car.minY + 0.00000 * car.height))
        carBodyPath.addCurve(to: CGPoint(x: car.minX + 0.74168 * car.width, y: car.minY + 0.30000 * car.height), controlPoint1: CGPoint(x: car.minX + 0.64942 * car.width, y: car.minY + 0.00000 * car.height), controlPoint2: CGPoint(x: car.minX + 0.74168 * car.width, y: car.minY + 0.30000 * car.height))
        carBodyPath.addCurve(to: CGPoint(x: car.minX + 0.95366 * car.width, y: car.minY + 0.36564 * car.height), controlPoint1: CGPoint(x: car.minX + 0.74168 * car.width, y: car.minY + 0.30000 * car.height), controlPoint2: CGPoint(x: car.minX + 0.89408 * car.width, y: car.minY + 0.28471 * car.height))
        carBodyPath.addCurve(to: CGPoint(x: car.minX + 0.99834 * car.width, y: car.minY + 0.62000 * car.height), controlPoint1: CGPoint(x: car.minX + 1.01324 * car.width, y: car.minY + 0.44657 * car.height), controlPoint2: CGPoint(x: car.minX + 0.99834 * car.width, y: car.minY + 0.62000 * car.height))
        carBodyPath.addLine(to: CGPoint(x: car.minX + 0.00037 * car.width, y: car.minY + 0.62000 * car.height))
        carBodyPath.addCurve(to: CGPoint(x: car.minX + 0.04505 * car.width, y: car.minY + 0.36564 * car.height), controlPoint1: CGPoint(x: car.minX + 0.00037 * car.width, y: car.minY + 0.62000 * car.height), controlPoint2: CGPoint(x: car.minX + -0.00708 * car.width, y: car.minY + 0.44657 * car.height))
        carBodyPath.close()
//        expression.setStroke()
//        carBodyPath.lineWidth = 3
//        carBodyPath.stroke()
        
        
        //// Wheel1 Drawing
        let wheel1Path = UIBezierPath(ovalIn: CGRect(x: car.minX + fastFloor(car.width * 0.14260) + 0.5, y: car.minY + fastFloor(car.height * 0.71757) + 0.5, width: fastFloor(car.width * 0.35574) - fastFloor(car.width * 0.14260), height: fastFloor(car.height * 0.99791) - fastFloor(car.height * 0.71757)))
//        expression.setStroke()
//        wheel1Path.lineWidth = 3
//        wheel1Path.stroke()
        
        
        //// Wheel2 Drawing
        let wheel2Path = UIBezierPath(ovalIn: CGRect(x: car.minX + fastFloor(car.width * 0.62742 + 0.5), y: car.minY + fastFloor(car.height * 0.71967 + 0.5), width: fastFloor(car.width * 0.84056 + 0.5) - fastFloor(car.width * 0.62742 + 0.5), height: fastFloor(car.height * 1.00000 + 0.5) - fastFloor(car.height * 0.71967 + 0.5)))
//        expression.setStroke()
//        wheel2Path.lineWidth = 3
//        wheel2Path.stroke()
        
        
        //// Window Drawing
        let windowPath = UIBezierPath()
        windowPath.move(to: CGPoint(x: car.minX + 0.45642 * car.width, y: car.minY + 0.08000 * car.height))
        windowPath.addLine(to: CGPoint(x: car.minX + 0.45642 * car.width, y: car.minY + 0.30000 * car.height))
        windowPath.addLine(to: CGPoint(x: car.minX + 0.67036 * car.width, y: car.minY + 0.30000 * car.height))
        windowPath.addCurve(to: CGPoint(x: car.minX + 0.59905 * car.width, y: car.minY + 0.16000 * car.height), controlPoint1: CGPoint(x: car.minX + 0.67036 * car.width, y: car.minY + 0.30000 * car.height), controlPoint2: CGPoint(x: car.minX + 0.65254 * car.width, y: car.minY + 0.21500 * car.height))
        windowPath.addCurve(to: CGPoint(x: car.minX + 0.45642 * car.width, y: car.minY + 0.08000 * car.height), controlPoint1: CGPoint(x: car.minX + 0.54556 * car.width, y: car.minY + 0.10500 * car.height), controlPoint2: CGPoint(x: car.minX + 0.45642 * car.width, y: car.minY + 0.08000 * car.height))
//        expression.setStroke()
//        windowPath.lineWidth = 2
//        windowPath.stroke()
        
        let bezierPath = UIBezierPath()
        bezierPath.append(carBodyPath)
        bezierPath.append(wheel1Path)
        bezierPath.append(wheel2Path)
        bezierPath.append(windowPath)
        
        expression.setStroke()
        bezierPath.lineWidth = 2
        bezierPath.stroke()
        
        bezierPath.addClip()
        
    }
    
    class func drawMisc(frame: CGRect = CGRect(x: 0, y: 0, width: 400, height: 400), isSelected: Bool = false) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }
        
        //// Variable Declarations
        let expression = isSelected ? Icons.selectedColor : Icons.unSelectedColor
        
        //// Subframes
        let group: CGRect = CGRect(x: frame.minX + fastFloor(frame.width * 0.32875) + 0.5, y: frame.minY + fastFloor(frame.height * 0.12875) + 0.5, width: fastFloor(frame.width * 0.67220 - 0.38) - fastFloor(frame.width * 0.32875) + 0.38, height: fastFloor(frame.height * 0.86875) - fastFloor(frame.height * 0.12875))
        
        
        //// Group
        //// Query Dot Drawing
        let queryDotPath = UIBezierPath(ovalIn: CGRect(x: group.minX + fastFloor(group.width * 0.34212 + 0.5), y: group.minY + fastFloor(group.height * 0.90541 + 0.5), width: fastFloor(group.width * 0.54593 + 0.5) - fastFloor(group.width * 0.34212 + 0.5), height: fastFloor(group.height * 1.00000 + 0.5) - fastFloor(group.height * 0.90541 + 0.5)))
        expression.setStroke()
        queryDotPath.lineWidth = 3
        queryDotPath.stroke()
        
        
        //// Query Drawing
        let queryPath = UIBezierPath()
        queryPath.move(to: CGPoint(x: group.minX + 0.00000 * group.width, y: group.minY + 0.22222 * group.height))
        queryPath.addCurve(to: CGPoint(x: group.minX + 0.44249 * group.width, y: group.minY + 0.00000 * group.height), controlPoint1: CGPoint(x: group.minX + 0.00000 * group.width, y: group.minY + 0.22222 * group.height), controlPoint2: CGPoint(x: group.minX + 0.03404 * group.width, y: group.minY + 0.00000 * group.height))
        queryPath.addCurve(to: CGPoint(x: group.minX + 0.98710 * group.width, y: group.minY + 0.26984 * group.height), controlPoint1: CGPoint(x: group.minX + 0.85095 * group.width, y: group.minY + 0.00000 * group.height), controlPoint2: CGPoint(x: group.minX + 1.05518 * group.width, y: group.minY + 0.12698 * group.height))
        queryPath.addCurve(to: CGPoint(x: group.minX + 0.44249 * group.width, y: group.minY + 0.52381 * group.height), controlPoint1: CGPoint(x: group.minX + 0.91902 * group.width, y: group.minY + 0.41270 * group.height), controlPoint2: CGPoint(x: group.minX + 0.44249 * group.width, y: group.minY + 0.52381 * group.height))
        queryPath.addLine(to: CGPoint(x: group.minX + 0.44249 * group.width, y: group.minY + 0.82540 * group.height))
        expression.setStroke()
        queryPath.lineWidth = 3
        queryPath.stroke()
    }
    
    class func drawUtilities(frame: CGRect = CGRect(x: 0, y: 0, width: 400, height: 400), isSelected: Bool = false) {
        
        //// Variable Declarations
        let expression = isSelected ? Icons.selectedColor : Icons.unSelectedColor
        
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: frame.minX + 0.73348 * frame.width, y: frame.minY + 0.09125 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.20625 * frame.width, y: frame.minY + 0.38052 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.57029 * frame.width, y: frame.minY + 0.51887 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.34434 * frame.width, y: frame.minY + 0.90875 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.79625 * frame.width, y: frame.minY + 0.48113 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.49497 * frame.width, y: frame.minY + 0.34279 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.73348 * frame.width, y: frame.minY + 0.09125 * frame.height))
        bezierPath.close()
        expression.setStroke()
        bezierPath.lineWidth = 3
        bezierPath.lineCapStyle = .square
        bezierPath.stroke()
    }
}
